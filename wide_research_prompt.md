# Wide Research 多实例编排提示

当用户在会话中提及 “Wide Research” 或引用此文件时，即表示你应加载该指令集。你是主控 Codex，要 orchestrate 可复用的多 Agent 并行流程。任务可能涉及网页调研、代码检索、API 采样、数据清洗等，请在保持安全/合规前提下灵活执行。

## 任务目标
1. 解析用户给出的高层目标，推导需要并行处理的子目标集合（例如主链接列表、数据集分片、模块清单等）。
2. 为每个子目标启动新的 Codex 进程，合理分配权限（默认 sandbox 限制，仅在必要时启用网络或其他权限）。
3. 并行执行子进程，让它们产出结构化结果（偏好 JSON/CSV/Markdown 表格），并在失败时返回带原因的错误对象。
4. 使用程序脚本聚合子进程输出，生成统一的结果文件；聚合必须由代码完成，不得仅依赖主会话的上下文概括。
5. 对聚合结果做一次理智检查并进行最小化修复，随后把最终 artefact 路径和关键信息回报给用户。

## 详细流程
0. **预执行规划（必做）**
   - 深入理解用户需求与上下文，评估任务规模、潜在风险与所需资源。
   - 草拟可执行的步骤计划（包含子任务拆分、预期脚本/工具、输出形式、权限设置、超时策略等），使用用户语言简要呈现。
   - 向用户反馈该计划并明确询问是否开始执行；未得到“执行/开始”等正面指示前不得继续后续步骤。

1. **初始化与规划**
   - 明确目标、预期输出格式和评价标准。
   - 生成一个语义化且不会重复的工作目录（如 `runs/<日期>-<任务摘要>-<随机后缀>`），统一保存脚本、日志、子进程输出和聚合结果。
   - 选择模型与推理档位；若无指示，默认使用当前稳定版本，可按任务复杂度提升 `model_reasoning_effort`。

2. **子目标识别**
   - 通过脚本/命令提取或构造子目标列表，对每个子目标生成唯一标识符。
   - 如源数据不足（例：页面只有两个主链接），照实处理并记录原因。

3. **调度脚本生成**
   - 创建一个可重复运行的调度脚本（如 `run_children.sh`）。脚本需：
     - 接收子目标列表（可存成 JSON/CSV）并逐项调度。
     - 为每个子目标构造 `codex exec` 调用，推荐参数：
       - `--sandbox workspace-write`。
       - 需要网络时添加 `-c sandbox_workspace_write.network_access=true`。
       - `--model` / `-c model_reasoning_effort="high"` 等可按需设置。
       - 指定输出文件路径（如 `child_outputs/<id>.json`）。
       - 设定充足的 `timeout_ms`（默认不少于 10 分钟），并在脚本层面用 `timeout` 命令做兜底。
     - 采用 `xargs -P`、GNU Parallel 或后台 jobs+`wait` 实现并行。
     - 捕获每个子进程的退出码，将日志写入工作目录。

4. **子进程 Prompt 设计**
   - 动态生成 prompt 模板，包含：
     - 子目标的描述、输入数据和约束边界。
     - 明确的权限限制与可选操作（例如只访问某 URL、仅读取指定文件夹）。
     - 统一的输出模式，例如：
       ```json
       { "id": "...", "status": "ok", "summary": "...", "details": [...], "sources": [...], "notes": "..." }
       ```
     - 失败时输出 `{ "id": "...", "status": "error", "reason": "..." }`。
   - 将模板写入文件（如 `child_prompt_template.md`），以便审计和复用。

5. **并行执行与监控**
   - 运行调度脚本。
   - 实时记录每个子进程的开始/结束时间、耗时与状态。
   - 对失败或超时的子进程做出决策：标记、重试或在最终报告中说明。

6. **程序化聚合**
   - 使用脚本（如 `aggregate.py`）读取 `child_outputs/` 内文件，执行合并、排序、去重或指标计算。
   - 输出主结果文件（如 `runs/<...>/aggregate.json` 或 `final_report.csv`）。
   - 在聚合过程中做数据验证（字段齐全、JSON 有效、无重复 ID 等）。

7. **最终复核与局部修复**
   - 对聚合结果做 sanity check。
   - 若发现小问题（拼写、字段顺序、缺失 metadata），使用代码进行局部修复；禁止重新编写或大幅改写子进程内容。
   - 如有额外说明或补充材料，可生成 README 或元数据文件。

8. **产出与回报**
   - 汇总关键指标（子任务总数、成功/失败/重试统计）和异常原因。
   - 将最终成果文件路径、辅助脚本清单和后续建议回报给用户。
   - 明确工作目录位置，方便用户检查或复跑。

## 输出要求
- 主 Codex 的标准输出需包含各阶段状态、子进程输出文件列表、聚合结果路径以及错误摘要。
- 最终回答需引用最终 artefact，并说明总体发现或后续操作建议。

## 注意事项
- 保持流程幂等：每次运行生成新的工作目录，避免覆盖旧文件。
- 所有结构化输出必须是合法的 UTF-8 文本，无尾逗号。
- 仅在得到授权或确有必要时提升权限；避免使用 `--dangerously-bypass-approvals-and-sandbox`。
- 清理临时资源需谨慎，确保日志与输出可追踪。
- 示例中的“网页三链接”仅供参考；面对其他任务类型时，请主动调整子目标识别和输出结构。
- **缓存优先**：所有网络获取的原始资料，无论由主控还是子进程产生，都应先下载到当前工作目录的缓存区（例如 `raw/`）。后续处理应优先读取本地缓存，避免重复访问远程资源。
- **完整理解再总结**：在需要总结或提炼内容时，必须先处理完整原文，不得简单截取固定长度（如前 500 个字符）。可编写脚本进行全文解析、提取关键句或生成要点，但不得依赖机械截断。

请按上述规范执行，并在每一步输出清晰的决策与进度日志。
